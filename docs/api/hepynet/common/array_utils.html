<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>hepynet.common.array_utils API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hepynet.common.array_utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
import time

import numpy as np

from hepynet.common import common_utils

logger = logging.getLogger(&#34;hepynet&#34;)


def clean_negative_weights(weights):
    &#34;&#34;&#34;removes elements with negative weight.

    Args:
        array: numpy array, input array to be processed, must be numpy array
        weight_id: int, indicate which column is weight value.
        verbose: bool, optional, show more detailed message if set True.

    Returns:
        cleaned new numpy array.
    &#34;&#34;&#34;
    # Start
    logger.debug(&#34;Cleaning array elements with negative weights...&#34;)
    new_weights = weights.copy()
    new_weights = np.clip(new_weights, a_min=0, a_max=None)
    logger.debug(
        f&#34;Shape before clean negative: {weights.shape}, shape after: {new_weights.shape}&#34;
    )
    return new_weights


def get_cut_index(array, cut_values, cut_types):
    &#34;&#34;&#34;Parses cuts arguments and returns cuts indexes.&#34;&#34;&#34;
    assert len(cut_values) == len(
        cut_types
    ), &#34;cut_values and cut_types should have same length.&#34;
    pass_index = None
    for cut_value, cut_type in zip(cut_values, cut_types):
        temp_index = get_cut_index_value(array, cut_value, cut_type)
        if pass_index is None:
            pass_index = temp_index
        else:
            pass_index = np.intersect1d(pass_index, temp_index)
    return pass_index


def get_cut_index_value(array, cut_value, cut_type):
    &#34;&#34;&#34;Returns cut indexes based on cut_value and cut_type.

    If cut_type is &#34;=&#34;:
        returns all indexes that have values equal to cut_value
    If cut_type is &#34;&gt;&#34;:
        returns all indexes that have values lager than cut_value
    If cut_type is &#34;&lt;&#34;:
        returns all indexes that have values smaller than cut_value

    Args:
        array_dict: numpy array
        cut_feature: str
        cut_bool: bool
    &#34;&#34;&#34;
    logger.debug(&#34;Cutting input array&#34;)
    logger.debug(f&#34;Input shape: {array.shape}&#34;)
    # Make cuts
    if cut_type == &#34;=&#34;:
        pass_index = np.argwhere(array == cut_value)
    elif cut_type == &#34;&gt;&#34;:
        pass_index = np.argwhere(array &gt; cut_value)
    elif cut_type == &#34;&lt;&#34;:
        pass_index = np.argwhere(array &lt; cut_value)
    else:
        raise ValueError(&#34;Invalid cut_type specified.&#34;)
    return pass_index.flatten()


def modify_array(
    input_array,
    input_weights,
    remove_negative_weight=False,
    reset_mass=False,
    reset_mass_array=None,
    reset_mass_weights=None,
    reset_mass_id=None,
    norm=False,
    sumofweight=1000,
    shuffle=False,
    shuffle_seed=None,
):
    &#34;&#34;&#34;Modifies numpy array with given setup.

    Args:
        input_array: numpy array
            Array to be modified.
        remove_negative_weight: bool, optional (default=False) 
            Whether to remove events with negative weight.
        reset_mass: bool, optional (default=None)
            Whether to reset mass with given array&#39;s value distribution.
            If set True, reset_mass_array/reset_mass_id shouldn&#39;t be None.
        reset_mass_array: numpy array or none, optional (default=None):
            Array used to reset input_array&#39;s mass distribution.
        reset_mass_id: int or None, optional (default=None)
            Column index of mass id to reset input_array.
        norm: bool, optional (default=False)
            Whether normalize array&#39;s weight to sumofweight.
        sumofweight: float or None, optional (default=None)
            Total normalized weight.
        shuffle: bool, optional (default=None)
            Whether to randomize the output array.
        shuffle_seed: int or None, optional (default=None)
            Seed for randomization process.
            Set to None to use current time as seed.
            Set to a specific value to get an unchanged shuffle result.

      Returns:
          new: numpy array
              Modified numpy array.

  &#34;&#34;&#34;
    # Modify
    new_array = input_array.copy()  # copy data to avoid original data operation
    new_weight = input_weights.copy()
    if len(new_array) == 0:
        logger.warning(&#34;empty input detected in modify_array, no changes will be made.&#34;)
        return new_array
    # clean array
    if remove_negative_weight:
        new_weight = clean_negative_weights(new_weight)
    # reset mass
    if reset_mass == True:
        if not common_utils.has_none([reset_mass_array, reset_mass_id]):
            new_array = reset_col(
                new_array, reset_mass_array, reset_mass_weights, col=reset_mass_id
            )
        else:
            logger.warning(&#34;missing parameters, skipping mass reset...&#34;)
    # normalize weight
    if norm == True:
        new_weight = norweight(new_weight, norm=sumofweight)
    # shuffle array
    if shuffle == True:
        new_array, _, _, _, new_weight, _ = shuffle_and_split(
            new_array,
            np.zeros(len(new_array)),
            new_weight,
            split_ratio=0.0,
            shuffle_seed=shuffle_seed,
        )
    # return result
    return new_array, new_weight


def norweight(weight_array, norm=1000):
    &#34;&#34;&#34;Normalize given weight array to certain value

    Args:
        weight_array: numpy array
            Array to be normalized.
        norm: float (default=1000)
            Value to be normalized to.

    Returns:
        new: numpy array
          normalized array.

    Example:
      arr has weight value saved in column -1.
      To normalize it&#39;s total weight to 1:
        arr[:, -1] = norweight(arr[:, -1], norm=1)

    &#34;&#34;&#34;
    new = weight_array.copy()  # copy data to avoid original data operation
    total_weight = sum(new)
    frac = norm / total_weight
    new = frac * new
    return new


def reset_col(reset_array, ref_array, ref_weights, col=0, shuffle_seed=None):
    &#34;&#34;&#34;Resets one column in an array based on the distribution of reference.&#34;&#34;&#34;
    if common_utils.has_none([shuffle_seed]):
        shuffle_seed = int(time.time())
    np.random.seed(shuffle_seed)
    new = reset_array.copy()
    total_events = len(new)
    positive_weights = (ref_weights.copy()).clip(min=0)
    if (positive_weights != ref_weights).all():
        logger.warning(&#34;Non-positive weights detected, set to zero&#34;)
    sump = sum(positive_weights)
    reset_list = np.random.choice(
        ref_array[:, col],
        size=total_events,
        p=(1 / sump) * positive_weights.reshape((-1,)),
    )
    new[:, col] = reset_list
    return new


def shuffle_and_split(x, y, wt, split_ratio=0.0, shuffle_seed=None):
    &#34;&#34;&#34;Self defined function to replace train_test_split in sklearn to allow
    more flexibility.
    &#34;&#34;&#34;
    # Check consistence of length of x, y
    if len(x) != len(y):
        raise ValueError(&#34;Length of x and y is not same.&#34;)
    array_len = len(y)
    np.random.seed(shuffle_seed)
    # get index for the first part of the split array
    first_part_index = np.random.choice(
        range(array_len), int(array_len * 1.0 * split_ratio), replace=False
    )
    # get index for last part of the splitted array
    last_part_index = np.setdiff1d(np.array(range(array_len)), first_part_index)
    first_part_x = x[first_part_index]
    first_part_y = y[first_part_index]
    first_part_wt = wt[first_part_index]
    last_part_x = x[last_part_index]
    last_part_y = y[last_part_index]
    last_part_wt = wt[last_part_index]
    return (
        first_part_x,
        last_part_x,
        first_part_y,
        last_part_y,
        first_part_wt,
        last_part_wt,
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hepynet.common.array_utils.clean_negative_weights"><code class="name flex">
<span>def <span class="ident">clean_negative_weights</span></span>(<span>weights)</span>
</code></dt>
<dd>
<div class="desc"><p>removes elements with negative weight.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>numpy array, input array to be processed, must be numpy array</dd>
<dt><strong><code>weight_id</code></strong></dt>
<dd>int, indicate which column is weight value.</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>bool, optional, show more detailed message if set True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>cleaned new numpy array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_negative_weights(weights):
    &#34;&#34;&#34;removes elements with negative weight.

    Args:
        array: numpy array, input array to be processed, must be numpy array
        weight_id: int, indicate which column is weight value.
        verbose: bool, optional, show more detailed message if set True.

    Returns:
        cleaned new numpy array.
    &#34;&#34;&#34;
    # Start
    logger.debug(&#34;Cleaning array elements with negative weights...&#34;)
    new_weights = weights.copy()
    new_weights = np.clip(new_weights, a_min=0, a_max=None)
    logger.debug(
        f&#34;Shape before clean negative: {weights.shape}, shape after: {new_weights.shape}&#34;
    )
    return new_weights</code></pre>
</details>
</dd>
<dt id="hepynet.common.array_utils.get_cut_index"><code class="name flex">
<span>def <span class="ident">get_cut_index</span></span>(<span>array, cut_values, cut_types)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses cuts arguments and returns cuts indexes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cut_index(array, cut_values, cut_types):
    &#34;&#34;&#34;Parses cuts arguments and returns cuts indexes.&#34;&#34;&#34;
    assert len(cut_values) == len(
        cut_types
    ), &#34;cut_values and cut_types should have same length.&#34;
    pass_index = None
    for cut_value, cut_type in zip(cut_values, cut_types):
        temp_index = get_cut_index_value(array, cut_value, cut_type)
        if pass_index is None:
            pass_index = temp_index
        else:
            pass_index = np.intersect1d(pass_index, temp_index)
    return pass_index</code></pre>
</details>
</dd>
<dt id="hepynet.common.array_utils.get_cut_index_value"><code class="name flex">
<span>def <span class="ident">get_cut_index_value</span></span>(<span>array, cut_value, cut_type)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns cut indexes based on cut_value and cut_type.</p>
<p>If cut_type is "=":
returns all indexes that have values equal to cut_value
If cut_type is "&gt;":
returns all indexes that have values lager than cut_value
If cut_type is "&lt;":
returns all indexes that have values smaller than cut_value</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array_dict</code></strong></dt>
<dd>numpy array</dd>
<dt><strong><code>cut_feature</code></strong></dt>
<dd>str</dd>
<dt><strong><code>cut_bool</code></strong></dt>
<dd>bool</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cut_index_value(array, cut_value, cut_type):
    &#34;&#34;&#34;Returns cut indexes based on cut_value and cut_type.

    If cut_type is &#34;=&#34;:
        returns all indexes that have values equal to cut_value
    If cut_type is &#34;&gt;&#34;:
        returns all indexes that have values lager than cut_value
    If cut_type is &#34;&lt;&#34;:
        returns all indexes that have values smaller than cut_value

    Args:
        array_dict: numpy array
        cut_feature: str
        cut_bool: bool
    &#34;&#34;&#34;
    logger.debug(&#34;Cutting input array&#34;)
    logger.debug(f&#34;Input shape: {array.shape}&#34;)
    # Make cuts
    if cut_type == &#34;=&#34;:
        pass_index = np.argwhere(array == cut_value)
    elif cut_type == &#34;&gt;&#34;:
        pass_index = np.argwhere(array &gt; cut_value)
    elif cut_type == &#34;&lt;&#34;:
        pass_index = np.argwhere(array &lt; cut_value)
    else:
        raise ValueError(&#34;Invalid cut_type specified.&#34;)
    return pass_index.flatten()</code></pre>
</details>
</dd>
<dt id="hepynet.common.array_utils.modify_array"><code class="name flex">
<span>def <span class="ident">modify_array</span></span>(<span>input_array, input_weights, remove_negative_weight=False, reset_mass=False, reset_mass_array=None, reset_mass_weights=None, reset_mass_id=None, norm=False, sumofweight=1000, shuffle=False, shuffle_seed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Modifies numpy array with given setup.</p>
<h2 id="args">Args</h2>
<p>input_array: numpy array
Array to be modified.
remove_negative_weight: bool, optional (default=False)
Whether to remove events with negative weight.
reset_mass: bool, optional (default=None)
Whether to reset mass with given array's value distribution.
If set True, reset_mass_array/reset_mass_id shouldn't be None.
reset_mass_array: numpy array or none, optional (default=None):
Array used to reset input_array's mass distribution.
reset_mass_id: int or None, optional (default=None)
Column index of mass id to reset input_array.
norm: bool, optional (default=False)
Whether normalize array's weight to sumofweight.
sumofweight: float or None, optional (default=None)
Total normalized weight.
shuffle: bool, optional (default=None)
Whether to randomize the output array.
shuffle_seed: int or None, optional (default=None)
Seed for randomization process.
Set to None to use current time as seed.
Set to a specific value to get an unchanged shuffle result.</p>
<p>Returns:
new: numpy array
Modified numpy array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def modify_array(
    input_array,
    input_weights,
    remove_negative_weight=False,
    reset_mass=False,
    reset_mass_array=None,
    reset_mass_weights=None,
    reset_mass_id=None,
    norm=False,
    sumofweight=1000,
    shuffle=False,
    shuffle_seed=None,
):
    &#34;&#34;&#34;Modifies numpy array with given setup.

    Args:
        input_array: numpy array
            Array to be modified.
        remove_negative_weight: bool, optional (default=False) 
            Whether to remove events with negative weight.
        reset_mass: bool, optional (default=None)
            Whether to reset mass with given array&#39;s value distribution.
            If set True, reset_mass_array/reset_mass_id shouldn&#39;t be None.
        reset_mass_array: numpy array or none, optional (default=None):
            Array used to reset input_array&#39;s mass distribution.
        reset_mass_id: int or None, optional (default=None)
            Column index of mass id to reset input_array.
        norm: bool, optional (default=False)
            Whether normalize array&#39;s weight to sumofweight.
        sumofweight: float or None, optional (default=None)
            Total normalized weight.
        shuffle: bool, optional (default=None)
            Whether to randomize the output array.
        shuffle_seed: int or None, optional (default=None)
            Seed for randomization process.
            Set to None to use current time as seed.
            Set to a specific value to get an unchanged shuffle result.

      Returns:
          new: numpy array
              Modified numpy array.

  &#34;&#34;&#34;
    # Modify
    new_array = input_array.copy()  # copy data to avoid original data operation
    new_weight = input_weights.copy()
    if len(new_array) == 0:
        logger.warning(&#34;empty input detected in modify_array, no changes will be made.&#34;)
        return new_array
    # clean array
    if remove_negative_weight:
        new_weight = clean_negative_weights(new_weight)
    # reset mass
    if reset_mass == True:
        if not common_utils.has_none([reset_mass_array, reset_mass_id]):
            new_array = reset_col(
                new_array, reset_mass_array, reset_mass_weights, col=reset_mass_id
            )
        else:
            logger.warning(&#34;missing parameters, skipping mass reset...&#34;)
    # normalize weight
    if norm == True:
        new_weight = norweight(new_weight, norm=sumofweight)
    # shuffle array
    if shuffle == True:
        new_array, _, _, _, new_weight, _ = shuffle_and_split(
            new_array,
            np.zeros(len(new_array)),
            new_weight,
            split_ratio=0.0,
            shuffle_seed=shuffle_seed,
        )
    # return result
    return new_array, new_weight</code></pre>
</details>
</dd>
<dt id="hepynet.common.array_utils.norweight"><code class="name flex">
<span>def <span class="ident">norweight</span></span>(<span>weight_array, norm=1000)</span>
</code></dt>
<dd>
<div class="desc"><p>Normalize given weight array to certain value</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>weight_array</code></strong></dt>
<dd>numpy array
Array to be normalized.</dd>
<dt><strong><code>norm</code></strong></dt>
<dd>float (default=1000)
Value to be normalized to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>new</code></dt>
<dd>numpy array
normalized array.</dd>
</dl>
<h2 id="example">Example</h2>
<p>arr has weight value saved in column -1.
To normalize it's total weight to 1:
arr[:, -1] = norweight(arr[:, -1], norm=1)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def norweight(weight_array, norm=1000):
    &#34;&#34;&#34;Normalize given weight array to certain value

    Args:
        weight_array: numpy array
            Array to be normalized.
        norm: float (default=1000)
            Value to be normalized to.

    Returns:
        new: numpy array
          normalized array.

    Example:
      arr has weight value saved in column -1.
      To normalize it&#39;s total weight to 1:
        arr[:, -1] = norweight(arr[:, -1], norm=1)

    &#34;&#34;&#34;
    new = weight_array.copy()  # copy data to avoid original data operation
    total_weight = sum(new)
    frac = norm / total_weight
    new = frac * new
    return new</code></pre>
</details>
</dd>
<dt id="hepynet.common.array_utils.reset_col"><code class="name flex">
<span>def <span class="ident">reset_col</span></span>(<span>reset_array, ref_array, ref_weights, col=0, shuffle_seed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets one column in an array based on the distribution of reference.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_col(reset_array, ref_array, ref_weights, col=0, shuffle_seed=None):
    &#34;&#34;&#34;Resets one column in an array based on the distribution of reference.&#34;&#34;&#34;
    if common_utils.has_none([shuffle_seed]):
        shuffle_seed = int(time.time())
    np.random.seed(shuffle_seed)
    new = reset_array.copy()
    total_events = len(new)
    positive_weights = (ref_weights.copy()).clip(min=0)
    if (positive_weights != ref_weights).all():
        logger.warning(&#34;Non-positive weights detected, set to zero&#34;)
    sump = sum(positive_weights)
    reset_list = np.random.choice(
        ref_array[:, col],
        size=total_events,
        p=(1 / sump) * positive_weights.reshape((-1,)),
    )
    new[:, col] = reset_list
    return new</code></pre>
</details>
</dd>
<dt id="hepynet.common.array_utils.shuffle_and_split"><code class="name flex">
<span>def <span class="ident">shuffle_and_split</span></span>(<span>x, y, wt, split_ratio=0.0, shuffle_seed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Self defined function to replace train_test_split in sklearn to allow
more flexibility.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shuffle_and_split(x, y, wt, split_ratio=0.0, shuffle_seed=None):
    &#34;&#34;&#34;Self defined function to replace train_test_split in sklearn to allow
    more flexibility.
    &#34;&#34;&#34;
    # Check consistence of length of x, y
    if len(x) != len(y):
        raise ValueError(&#34;Length of x and y is not same.&#34;)
    array_len = len(y)
    np.random.seed(shuffle_seed)
    # get index for the first part of the split array
    first_part_index = np.random.choice(
        range(array_len), int(array_len * 1.0 * split_ratio), replace=False
    )
    # get index for last part of the splitted array
    last_part_index = np.setdiff1d(np.array(range(array_len)), first_part_index)
    first_part_x = x[first_part_index]
    first_part_y = y[first_part_index]
    first_part_wt = wt[first_part_index]
    last_part_x = x[last_part_index]
    last_part_y = y[last_part_index]
    last_part_wt = wt[last_part_index]
    return (
        first_part_x,
        last_part_x,
        first_part_y,
        last_part_y,
        first_part_wt,
        last_part_wt,
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hepynet.common" href="index.html">hepynet.common</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="hepynet.common.array_utils.clean_negative_weights" href="#hepynet.common.array_utils.clean_negative_weights">clean_negative_weights</a></code></li>
<li><code><a title="hepynet.common.array_utils.get_cut_index" href="#hepynet.common.array_utils.get_cut_index">get_cut_index</a></code></li>
<li><code><a title="hepynet.common.array_utils.get_cut_index_value" href="#hepynet.common.array_utils.get_cut_index_value">get_cut_index_value</a></code></li>
<li><code><a title="hepynet.common.array_utils.modify_array" href="#hepynet.common.array_utils.modify_array">modify_array</a></code></li>
<li><code><a title="hepynet.common.array_utils.norweight" href="#hepynet.common.array_utils.norweight">norweight</a></code></li>
<li><code><a title="hepynet.common.array_utils.reset_col" href="#hepynet.common.array_utils.reset_col">reset_col</a></code></li>
<li><code><a title="hepynet.common.array_utils.shuffle_and_split" href="#hepynet.common.array_utils.shuffle_and_split">shuffle_and_split</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>