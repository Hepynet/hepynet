<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>hepynet.evaluate.evaluate_utils API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hepynet.evaluate.evaluate_utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
import pathlib
from typing import Tuple

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

from hepynet.common import config_utils
from hepynet.data_io import numpy_io
from hepynet.train import hep_model

logger = logging.getLogger(&#34;hepynet&#34;)


def create_epoch_subdir(save_dir, epoch, n_digit) -&gt; pathlib.Path:
    if save_dir is None:
        logger.error(f&#34;Invalid save_dir: {save_dir}&#34;)
        return None
    if epoch is not None:
        sub_dir = pathlib.Path(f&#34;{save_dir}/epoch_{str(epoch).zfill(n_digit)}&#34;)
    else:
        sub_dir = pathlib.Path(f&#34;{save_dir}/epoch_final&#34;)
    sub_dir.mkdir(parents=True, exist_ok=True)
    return sub_dir


def dump_fit_df(
    model_wrapper: hep_model.Model_Base,
    df_raw,
    df_train,
    job_config,
    save_dir=&#34;./&#34;,
):
    ic = job_config.input.clone()
    tc = job_config.train.clone()
    ac = job_config.apply.clone()

    sample_list = ic.sig_list + ic.bkg_list
    if ic.apply_data:
        sample_list += ic.data_list

    platform_meta = config_utils.load_current_platform_meta()
    data_path = platform_meta[&#34;data_path&#34;]
    if not data_path:
        save_dir = pathlib.Path(save_dir)
    else:
        save_dir = pathlib.Path(data_path) / save_dir
    pathlib.Path(save_dir).mkdir(parents=True, exist_ok=True)
    logger.info(f&#34;&gt; Saving dataframes to: {save_dir}&#34;)

    for sample in sample_list:
        logger.info(f&#34;&gt; &gt; processing: {sample}&#34;)
        dump_branches = ac.fit_df.branches + [&#34;weight&#34;]
        # prepare contents
        dump_df: pd.DataFrame = df_raw.loc[
            df_raw[&#34;sample_name&#34;] == sample, dump_branches
        ]
        input_df = df_train.loc[
            df_train[&#34;sample_name&#34;] == sample, ic.selected_features
        ]
        predictions, _, _ = k_folds_predict(
            model_wrapper.get_model(), input_df.values, silence=True
        )
        # dump
        if len(tc.output_bkg_node_names) == 0:
            dump_df[&#34;dnn_out_sig&#34;] = predictions
        else:
            for i, out_node in enumerate([&#34;sig&#34;] + tc.output_bkg_node_names):
                out_node = out_node.replace(&#34;+&#34;, &#34;_&#34;)
                branch_name = f&#34;dnn_out_{out_node}&#34;
                dump_df[branch_name] = predictions[:, i]
        dump_df.reset_index(inplace=True)
        save_path = save_dir / f&#34;{sample}.feather&#34;
        dump_df.to_feather(save_path)


def dump_fit_npy(
    model_wrapper: hep_model.Model_Base,
    df_raw,
    df_train,
    job_config,
    npy_dir=&#34;./&#34;,
):
    ic = job_config.input.clone()
    tc = job_config.train.clone()
    ac = job_config.apply.clone()

    sample_list = ic.sig_list + ic.bkg_list
    if ic.apply_data:
        sample_list += ic.data_list

    platform_meta = config_utils.load_current_platform_meta()
    data_path = platform_meta[&#34;data_path&#34;]
    if not data_path:
        save_dir = pathlib.Path(npy_dir)
    else:
        save_dir = pathlib.Path(data_path) / npy_dir
    pathlib.Path(save_dir).mkdir(parents=True, exist_ok=True)
    logger.info(f&#34;&gt; Arrays to be saved to {save_dir}&#34;)

    for sample in sample_list:
        dump_branches = ac.cfg_fit_npy.fit_npy_branches + [&#34;weight&#34;]
        # prepare contents
        dump_df = df_raw.loc[df_raw[&#34;sample_name&#34;] == sample, dump_branches]
        input_df = df_train.loc[
            df_train[&#34;sample_name&#34;] == sample, ic.selected_features
        ]
        predictions, _, _ = k_folds_predict(
            model_wrapper.get_model(), input_df.values
        )
        # dump
        for branch in dump_branches:
            branch_content = dump_df[branch].values
            save_path = f&#34;{save_dir}/{sample}_{branch}.npy&#34;
            numpy_io.save_npy_array(branch_content, save_path)
        if len(tc.output_bkg_node_names) == 0:
            save_path = f&#34;{save_dir}/{sample}_dnn_out.npy&#34;
            numpy_io.save_npy_array(predictions, save_path)
        else:
            for i, out_node in enumerate([&#34;sig&#34;] + tc.output_bkg_node_names):
                out_node = out_node.replace(&#34;+&#34;, &#34;_&#34;)
                save_path = f&#34;{save_dir}/{sample}_dnn_out_{out_node}.npy&#34;
                numpy_io.save_npy_array(predictions[:, i], save_path)


def k_folds_predict(
    k_fold_models, x, silence=False
) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:
    y_pred_k_folds = list()
    if not silence:
        logger.info(&#34;Predicting y scores&#34;)
    num_folds = len(k_fold_models)
    for fold_num, fold_model in enumerate(k_fold_models):
        if not silence:
            logger.info(
                f&#34;&gt; Predicting with model in fold {fold_num + 1}/{num_folds}&#34;
            )
        y_fold_pred = fold_model.predict(x)
        y_pred_k_folds.append(y_fold_pred)
    y_pred_mean = np.mean(y_pred_k_folds, axis=0)
    y_pred_max = np.maximum.reduce(y_pred_k_folds)
    y_pred_min = np.minimum.reduce(y_pred_k_folds)
    return y_pred_mean, y_pred_min, y_pred_max


def paint_bars(
    ax,
    data,
    labels: list,
    weights,
    bins: int,
    range: tuple,
    title: str = None,
    x_label: str = None,
    y_label: str = None,
    x_unit: str = None,
    x_scale: float = None,
    density: bool = False,
    use_error: bool = False,
    color: str = None,
    fmt: str = &#34;.k&#34;,
) -&gt; None:
    &#34;&#34;&#34;Plot with vertical bar, can be used for data display.

        Note:
        According to ROOT:
        &#34;The error per bin will be computed as sqrt(sum of squares of weight) for each bin.&#34;

    &#34;&#34;&#34;
    plt.ioff()
    # Check input
    data_1dim = np.array([])
    weight_1dim = np.array([])
    if isinstance(data, np.ndarray):
        data = [data]
        weights = [weights]
    for datum, weight in zip(data, weights):
        assert isinstance(
            datum, np.ndarray
        ), &#34;data element should be numpy array.&#34;
        assert isinstance(
            weight, np.ndarray
        ), &#34;weights element should be numpy array.&#34;
        assert (
            datum.shape == weight.shape
        ), &#34;Input weights should be None or have same type as arrays.&#34;
        if len(data_1dim) == 0:
            data_1dim = datum
            weight_1dim = weight
        else:
            data_1dim = np.concatenate((data_1dim, datum))
            weight_1dim = np.concatenate((weight_1dim, weight))

    # Scale x axis
    if x_scale is not None:
        data_1dim = data_1dim * x_scale
    # Make bar plot
    # get bin error and edges
    plot_ys, _ = np.histogram(
        data_1dim, bins=bins, range=range, weights=weight_1dim, density=density
    )
    sum_weight_squares, bin_edges = np.histogram(
        data_1dim, bins=bins, range=range, weights=np.power(weight_1dim, 2)
    )
    if density:
        error_scale = 1 / (np.sum(weight_1dim) * (range[1] - range[0]) / bins)
        errors = np.sqrt(sum_weight_squares) * error_scale
    else:
        errors = np.sqrt(sum_weight_squares)
    # Only plot ratio when bin is not 0.
    bin_centers = np.array([])
    bin_ys = np.array([])
    bin_yerrs = np.array([])
    for i, y1 in enumerate(plot_ys):
        if y1 != 0:
            ele_center = np.array([0.5 * (bin_edges[i] + bin_edges[i + 1])])
            bin_centers = np.concatenate((bin_centers, ele_center))
            ele_y = np.array([y1])
            bin_ys = np.concatenate((bin_ys, ele_y))
            ele_yerr = np.array([errors[i]])
            bin_yerrs = np.concatenate((bin_yerrs, ele_yerr))
    # plot bar
    bin_size = bin_edges[1] - bin_edges[0]
    if use_error:
        ax.errorbar(
            bin_centers,
            bin_ys,
            xerr=bin_size / 2.0,
            yerr=bin_yerrs,
            fmt=fmt,
            label=labels,
            color=color,
            markerfacecolor=color,
            markeredgecolor=color,
        )
    else:
        ax.errorbar(
            bin_centers,
            bin_ys,
            xerr=bin_size / 2.0,
            yerr=None,
            fmt=fmt,
            label=labels,
            color=color,
            markerfacecolor=color,
            markeredgecolor=color,
        )
    # Config
    if title is not None:
        ax.set_title(title)
    if x_label is not None:
        if x_unit is not None:
            ax.set_xlabel(x_label + &#34;/&#34; + x_unit)
        else:
            ax.set_xlabel(x_label)
    else:
        if x_unit is not None:
            ax.set_xlabel(x_unit)
    if y_label is not None:
        ax.set_ylabel(y_label)
    if range is not None:
        ax.axis(xmin=range[0], xmax=range[1])
    ax.legend(loc=&#34;upper right&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hepynet.evaluate.evaluate_utils.create_epoch_subdir"><code class="name flex">
<span>def <span class="ident">create_epoch_subdir</span></span>(<span>save_dir, epoch, n_digit) ‑> pathlib.Path</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_epoch_subdir(save_dir, epoch, n_digit) -&gt; pathlib.Path:
    if save_dir is None:
        logger.error(f&#34;Invalid save_dir: {save_dir}&#34;)
        return None
    if epoch is not None:
        sub_dir = pathlib.Path(f&#34;{save_dir}/epoch_{str(epoch).zfill(n_digit)}&#34;)
    else:
        sub_dir = pathlib.Path(f&#34;{save_dir}/epoch_final&#34;)
    sub_dir.mkdir(parents=True, exist_ok=True)
    return sub_dir</code></pre>
</details>
</dd>
<dt id="hepynet.evaluate.evaluate_utils.dump_fit_df"><code class="name flex">
<span>def <span class="ident">dump_fit_df</span></span>(<span>model_wrapper: <a title="hepynet.train.hep_model.Model_Base" href="../train/hep_model.html#hepynet.train.hep_model.Model_Base">Model_Base</a>, df_raw, df_train, job_config, save_dir='./')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_fit_df(
    model_wrapper: hep_model.Model_Base,
    df_raw,
    df_train,
    job_config,
    save_dir=&#34;./&#34;,
):
    ic = job_config.input.clone()
    tc = job_config.train.clone()
    ac = job_config.apply.clone()

    sample_list = ic.sig_list + ic.bkg_list
    if ic.apply_data:
        sample_list += ic.data_list

    platform_meta = config_utils.load_current_platform_meta()
    data_path = platform_meta[&#34;data_path&#34;]
    if not data_path:
        save_dir = pathlib.Path(save_dir)
    else:
        save_dir = pathlib.Path(data_path) / save_dir
    pathlib.Path(save_dir).mkdir(parents=True, exist_ok=True)
    logger.info(f&#34;&gt; Saving dataframes to: {save_dir}&#34;)

    for sample in sample_list:
        logger.info(f&#34;&gt; &gt; processing: {sample}&#34;)
        dump_branches = ac.fit_df.branches + [&#34;weight&#34;]
        # prepare contents
        dump_df: pd.DataFrame = df_raw.loc[
            df_raw[&#34;sample_name&#34;] == sample, dump_branches
        ]
        input_df = df_train.loc[
            df_train[&#34;sample_name&#34;] == sample, ic.selected_features
        ]
        predictions, _, _ = k_folds_predict(
            model_wrapper.get_model(), input_df.values, silence=True
        )
        # dump
        if len(tc.output_bkg_node_names) == 0:
            dump_df[&#34;dnn_out_sig&#34;] = predictions
        else:
            for i, out_node in enumerate([&#34;sig&#34;] + tc.output_bkg_node_names):
                out_node = out_node.replace(&#34;+&#34;, &#34;_&#34;)
                branch_name = f&#34;dnn_out_{out_node}&#34;
                dump_df[branch_name] = predictions[:, i]
        dump_df.reset_index(inplace=True)
        save_path = save_dir / f&#34;{sample}.feather&#34;
        dump_df.to_feather(save_path)</code></pre>
</details>
</dd>
<dt id="hepynet.evaluate.evaluate_utils.dump_fit_npy"><code class="name flex">
<span>def <span class="ident">dump_fit_npy</span></span>(<span>model_wrapper: <a title="hepynet.train.hep_model.Model_Base" href="../train/hep_model.html#hepynet.train.hep_model.Model_Base">Model_Base</a>, df_raw, df_train, job_config, npy_dir='./')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_fit_npy(
    model_wrapper: hep_model.Model_Base,
    df_raw,
    df_train,
    job_config,
    npy_dir=&#34;./&#34;,
):
    ic = job_config.input.clone()
    tc = job_config.train.clone()
    ac = job_config.apply.clone()

    sample_list = ic.sig_list + ic.bkg_list
    if ic.apply_data:
        sample_list += ic.data_list

    platform_meta = config_utils.load_current_platform_meta()
    data_path = platform_meta[&#34;data_path&#34;]
    if not data_path:
        save_dir = pathlib.Path(npy_dir)
    else:
        save_dir = pathlib.Path(data_path) / npy_dir
    pathlib.Path(save_dir).mkdir(parents=True, exist_ok=True)
    logger.info(f&#34;&gt; Arrays to be saved to {save_dir}&#34;)

    for sample in sample_list:
        dump_branches = ac.cfg_fit_npy.fit_npy_branches + [&#34;weight&#34;]
        # prepare contents
        dump_df = df_raw.loc[df_raw[&#34;sample_name&#34;] == sample, dump_branches]
        input_df = df_train.loc[
            df_train[&#34;sample_name&#34;] == sample, ic.selected_features
        ]
        predictions, _, _ = k_folds_predict(
            model_wrapper.get_model(), input_df.values
        )
        # dump
        for branch in dump_branches:
            branch_content = dump_df[branch].values
            save_path = f&#34;{save_dir}/{sample}_{branch}.npy&#34;
            numpy_io.save_npy_array(branch_content, save_path)
        if len(tc.output_bkg_node_names) == 0:
            save_path = f&#34;{save_dir}/{sample}_dnn_out.npy&#34;
            numpy_io.save_npy_array(predictions, save_path)
        else:
            for i, out_node in enumerate([&#34;sig&#34;] + tc.output_bkg_node_names):
                out_node = out_node.replace(&#34;+&#34;, &#34;_&#34;)
                save_path = f&#34;{save_dir}/{sample}_dnn_out_{out_node}.npy&#34;
                numpy_io.save_npy_array(predictions[:, i], save_path)</code></pre>
</details>
</dd>
<dt id="hepynet.evaluate.evaluate_utils.k_folds_predict"><code class="name flex">
<span>def <span class="ident">k_folds_predict</span></span>(<span>k_fold_models, x, silence=False) ‑> Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def k_folds_predict(
    k_fold_models, x, silence=False
) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:
    y_pred_k_folds = list()
    if not silence:
        logger.info(&#34;Predicting y scores&#34;)
    num_folds = len(k_fold_models)
    for fold_num, fold_model in enumerate(k_fold_models):
        if not silence:
            logger.info(
                f&#34;&gt; Predicting with model in fold {fold_num + 1}/{num_folds}&#34;
            )
        y_fold_pred = fold_model.predict(x)
        y_pred_k_folds.append(y_fold_pred)
    y_pred_mean = np.mean(y_pred_k_folds, axis=0)
    y_pred_max = np.maximum.reduce(y_pred_k_folds)
    y_pred_min = np.minimum.reduce(y_pred_k_folds)
    return y_pred_mean, y_pred_min, y_pred_max</code></pre>
</details>
</dd>
<dt id="hepynet.evaluate.evaluate_utils.paint_bars"><code class="name flex">
<span>def <span class="ident">paint_bars</span></span>(<span>ax, data, labels: list, weights, bins: int, range: tuple, title: str = None, x_label: str = None, y_label: str = None, x_unit: str = None, x_scale: float = None, density: bool = False, use_error: bool = False, color: str = None, fmt: str = '.k') ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Plot with vertical bar, can be used for data display.</p>
<p>Note:
According to ROOT:
"The error per bin will be computed as sqrt(sum of squares of weight) for each bin."</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paint_bars(
    ax,
    data,
    labels: list,
    weights,
    bins: int,
    range: tuple,
    title: str = None,
    x_label: str = None,
    y_label: str = None,
    x_unit: str = None,
    x_scale: float = None,
    density: bool = False,
    use_error: bool = False,
    color: str = None,
    fmt: str = &#34;.k&#34;,
) -&gt; None:
    &#34;&#34;&#34;Plot with vertical bar, can be used for data display.

        Note:
        According to ROOT:
        &#34;The error per bin will be computed as sqrt(sum of squares of weight) for each bin.&#34;

    &#34;&#34;&#34;
    plt.ioff()
    # Check input
    data_1dim = np.array([])
    weight_1dim = np.array([])
    if isinstance(data, np.ndarray):
        data = [data]
        weights = [weights]
    for datum, weight in zip(data, weights):
        assert isinstance(
            datum, np.ndarray
        ), &#34;data element should be numpy array.&#34;
        assert isinstance(
            weight, np.ndarray
        ), &#34;weights element should be numpy array.&#34;
        assert (
            datum.shape == weight.shape
        ), &#34;Input weights should be None or have same type as arrays.&#34;
        if len(data_1dim) == 0:
            data_1dim = datum
            weight_1dim = weight
        else:
            data_1dim = np.concatenate((data_1dim, datum))
            weight_1dim = np.concatenate((weight_1dim, weight))

    # Scale x axis
    if x_scale is not None:
        data_1dim = data_1dim * x_scale
    # Make bar plot
    # get bin error and edges
    plot_ys, _ = np.histogram(
        data_1dim, bins=bins, range=range, weights=weight_1dim, density=density
    )
    sum_weight_squares, bin_edges = np.histogram(
        data_1dim, bins=bins, range=range, weights=np.power(weight_1dim, 2)
    )
    if density:
        error_scale = 1 / (np.sum(weight_1dim) * (range[1] - range[0]) / bins)
        errors = np.sqrt(sum_weight_squares) * error_scale
    else:
        errors = np.sqrt(sum_weight_squares)
    # Only plot ratio when bin is not 0.
    bin_centers = np.array([])
    bin_ys = np.array([])
    bin_yerrs = np.array([])
    for i, y1 in enumerate(plot_ys):
        if y1 != 0:
            ele_center = np.array([0.5 * (bin_edges[i] + bin_edges[i + 1])])
            bin_centers = np.concatenate((bin_centers, ele_center))
            ele_y = np.array([y1])
            bin_ys = np.concatenate((bin_ys, ele_y))
            ele_yerr = np.array([errors[i]])
            bin_yerrs = np.concatenate((bin_yerrs, ele_yerr))
    # plot bar
    bin_size = bin_edges[1] - bin_edges[0]
    if use_error:
        ax.errorbar(
            bin_centers,
            bin_ys,
            xerr=bin_size / 2.0,
            yerr=bin_yerrs,
            fmt=fmt,
            label=labels,
            color=color,
            markerfacecolor=color,
            markeredgecolor=color,
        )
    else:
        ax.errorbar(
            bin_centers,
            bin_ys,
            xerr=bin_size / 2.0,
            yerr=None,
            fmt=fmt,
            label=labels,
            color=color,
            markerfacecolor=color,
            markeredgecolor=color,
        )
    # Config
    if title is not None:
        ax.set_title(title)
    if x_label is not None:
        if x_unit is not None:
            ax.set_xlabel(x_label + &#34;/&#34; + x_unit)
        else:
            ax.set_xlabel(x_label)
    else:
        if x_unit is not None:
            ax.set_xlabel(x_unit)
    if y_label is not None:
        ax.set_ylabel(y_label)
    if range is not None:
        ax.axis(xmin=range[0], xmax=range[1])
    ax.legend(loc=&#34;upper right&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hepynet.evaluate" href="index.html">hepynet.evaluate</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="hepynet.evaluate.evaluate_utils.create_epoch_subdir" href="#hepynet.evaluate.evaluate_utils.create_epoch_subdir">create_epoch_subdir</a></code></li>
<li><code><a title="hepynet.evaluate.evaluate_utils.dump_fit_df" href="#hepynet.evaluate.evaluate_utils.dump_fit_df">dump_fit_df</a></code></li>
<li><code><a title="hepynet.evaluate.evaluate_utils.dump_fit_npy" href="#hepynet.evaluate.evaluate_utils.dump_fit_npy">dump_fit_npy</a></code></li>
<li><code><a title="hepynet.evaluate.evaluate_utils.k_folds_predict" href="#hepynet.evaluate.evaluate_utils.k_folds_predict">k_folds_predict</a></code></li>
<li><code><a title="hepynet.evaluate.evaluate_utils.paint_bars" href="#hepynet.evaluate.evaluate_utils.paint_bars">paint_bars</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>